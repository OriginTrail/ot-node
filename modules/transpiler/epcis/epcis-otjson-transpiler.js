const xml2js = require('xml-js');
const uuidv4 = require('uuid/v4');
const xsd = require('libxml-xsd');
const utilities = require('../../Utilities');
const fs = require('fs');

const { sha3_256 } = require('js-sha3');
const deepExtend = require('deep-extend');

const Utilities = require('../../Utilities');
const Merkle = require('../../Merkle');
const sortedStringify = require('sorted-json-stringify');

class EpcisOtJsonTranspiler {
    constructor(ctx) {
        this.config = ctx.config;
        this.web3 = ctx.web3;
    }

    /**
     * Convert EPCIS XML document to OT-JSON
     * @param xml - XML string
     * @return {*} - OT-JSON object
     */
    convertToOTJson(xml) {
        if (xml == null) {
            return null;
        }

        const xsdFileBuffer = fs.readFileSync('./modules/transpiler/epcis/xsd_schemas/EPCglobal-epcis-masterdata-1_2.xsd');
        const schema = xsd.parse(xsdFileBuffer.toString());

        const validationResult = schema.validate(xml);
        if (validationResult !== null) {
            throw Error(`Failed to validate schema. ${validationResult}`);
        }

        const jsonRaw = xml2js.xml2js(xml, {
            compact: true,
            spaces: 4,
        });
        const json = this._removeCommentsAndTrimTexts(jsonRaw);
        this.arrayze(json, ['attribute', 'VocabularyElement', 'Vocabulary', 'epc', 'AggregationEvent', 'ObjectEvent', 'TransactionEvent', 'TransformationEvent', 'quantityElement', 'childQuantityList', 'source', 'destination', 'childEPCs', 'bizTransaction']);

        const otjson = {
            '@graph': [],
        };

        const otEvents = this._convertEventsFromJson(json);
        const otVocabularyObjects = this._convertVocabulariesFromJson(json);

        otjson['@graph'].push(...otVocabularyObjects);
        otjson['@graph'].push(...otEvents);

        const otGeneratedVocabularyObjects = this._createNonExistingVocabularyData(otjson['@graph']);
        otjson['@graph'].push(...otGeneratedVocabularyObjects);

        const otConnectors = [];
        for (const otEvent of otEvents) {
            const newConnectors = this._createConnectors(otEvent);
            otConnectors.push(...newConnectors);
        }
        otjson['@graph'].push(...otConnectors);

        if (otEvents.length > 0) {
            delete json['epcis:EPCISDocument'].EPCISBody.EventList;
        }

        if (otVocabularyObjects.length > 0) {
            delete json['epcis:EPCISDocument'].EPCISHeader.extension.EPCISMasterData.VocabularyList.Vocabulary;
        }

        const transpilationInfo = this._getTranspilationInfo();
        transpilationInfo.diff = json;

        otjson['@id'] = `0x${sha3_256(JSON.stringify(EpcisOtJsonTranspiler.sortGraphRecursively(otjson['@graph']), null, 0))}`;
        otjson['@type'] = 'Dataset';

        otjson.datasetHeader = this._createDatasetHeader(transpilationInfo);

        const datasetSummary = {
            datasetId: otjson['@id'],
            datasetCreator: otjson.datasetHeader.dataCreator,
            objects: otjson['@graph'].map(vertex => ({
                '@id': vertex['@id'],
                identifiers: vertex.identifiers != null ? vertex.identifiers : [],
            })),
            numRelations: otjson['@graph']
                .filter(vertex => vertex.relations != null)
                .reduce((acc, value) => acc + value.relations.length, 0),
        };

        const merkle = new Merkle(
            [JSON.stringify(datasetSummary), ...otjson['@graph'].map(v => JSON.stringify(v))],
            'sha3',
        );
        otjson.datasetHeader.dataIntegrity.proofs[0].proofValue = merkle.getRoot();

        const { signature } = this.web3.eth.accounts.sign(
            Utilities.soliditySHA3(JSON.stringify(otjson)),
            Utilities.normalizeHex(this.config.node_private_key),
        );

        otjson.signature = {
            value: signature,
            type: 'ethereum-signature',
        };

        return otjson;
    }

    /**
     * Creates non existing vocabulary data
     * @private
     */
    _createNonExistingVocabularyData(graph) {
        const results = [];
        const filtered = graph.filter(e => e.relations != null && e.relations.length > 0);
        for (const element of filtered) {
            const { relations } = element;
            for (const relation of relations) {
                const id = relation.linkedObject['@id'];
                const existing = graph.find(e => e['@id'] === id);
                if (existing != null) {
                    // eslint-disable-next-line
                    continue;
                }
                const vocabularyElement = {
                    '@type': 'otObject',
                    '@id': id,
                    properties: {
                        objectType: 'vocabularyElement',
                        ___autogenerated: true,
                    },
                };
                vocabularyElement.identifiers = Object.entries(this._parseGS1Identifier(id)).map(([key, value]) => ({ '@type': key, '@value': value }));
                results.push(vocabularyElement);
            }
        }
        return results;
    }

    /**
     * Remove comments from raw json
     */
    _removeCommentsAndTrimTexts(obj) {
        if (typeof obj === 'object' || Array.isArray((obj))) {
            if (this._isLeaf(obj)) {
                obj._text = obj._text.trim();
            }
            if (obj._comment) {
                delete obj._comment;
            }
            for (const key of Object.keys(obj)) {
                obj[key] = this._removeCommentsAndTrimTexts(obj[key]);
            }
        }
        return obj;
    }

    /**
     * Fill in dataset header
     * @private
     */
    _createDatasetHeader(transpilationInfo) {
        return {
            OTJSONVersion: '1.0',
            datasetCreationTimestamp: new Date().toISOString(),
            datasetTitle: '',
            datasetTags: [],
            /*
            relatedDatasets may contain objects like this:
            {
                datasetId: '0x620867dced3a96809fc69d579b2684a7',
                relationType: 'UPDATED',
                relationDescription: 'Some long description',
                relationDirection: 'direct',
            }
             */
            relatedDatasets: [],
            validationSchemas: {
                'erc725-main': {
                    schemaType: 'ethereum-725',
                    networkId: this.config.blockchain.network_id,
                },
                merkleRoot: {
                    schemaType: 'merkle-root',
                    networkId: this.config.blockchain.network_id,
                    hubContractAddress: this.config.blockchain.hubContractAddress,
                    // TODO: Add holding contract address and version. Hub address is useless.
                },
            },
            dataIntegrity: {
                proofs: [
                    {
                        proofValue: '0x2029a07cc3dc96a82b3260ebc1fed1d7',
                        proofType: 'merkleRootHash',
                        validationSchema: '/schemas/merkleRoot',
                    },
                ],
            },
            dataCreator: {
                identifiers: [
                    {
                        identifierValue: this.config.erc725Identity,
                        identifierType: 'ERC725',
                        validationSchema: '/schemas/erc725-main',
                    },
                ],
            },
            transpilationInfo,
        };
    }

    /**
     * Sort @graph data inline
     * @param graph
     */
    static sortGraphRecursively(graph) {
        graph.forEach(item => EpcisOtJsonTranspiler.sortObjectRecursively(item));
        graph.sort((e1, e2) => e1['@id'].localeCompare(e2['@id']));
        return graph;
    }

    /**
     * Sort object recursively
     */
    static sortObjectRecursively(object) {
        if (object == null) {
            return null;
        }
        if (Array.isArray(object)) { // skip array sorting
            const isScalarArray = object.reduce((accumulator, currentValue) => accumulator && (typeof currentValue !== 'object'), true);

            if (isScalarArray) {
                return object;
            }

            object.forEach(item => this.sortObjectRecursively(item));
            object.sort((item1, item2) => sha3_256(sortedStringify(item1, null))
                .localeCompare(sha3_256(sortedStringify((item2, null)))));
            return object;
        } else if (typeof object === 'object') {
            for (const key of Object.keys(object)) {
                if (key !== '___metadata') {
                    EpcisOtJsonTranspiler.sortObjectRecursively(object[key]);
                }
            }
            const ordered = {};
            Object.keys(object).sort().forEach(key => ordered[key] = object[key]);
            return ordered;
        }
        return object;
    }

    /**
     * Convert OT-JSON to EPCIS XML document
     * @param otjson - OT-JSON object
     * @return {string} - XML string
     */
    convertFromOTJson(otjson) {
        const json = utilities.copyObject(otjson.datasetHeader.transpilationInfo.diff);

        const graph = utilities.copyObject(otjson['@graph']);
        const otVocabularyObjects = graph.filter(x => x.properties != null && x.properties.objectType === 'vocabularyElement');
        if (otVocabularyObjects.length > 0) {
            json['epcis:EPCISDocument'].EPCISHeader.extension.EPCISMasterData.VocabularyList = this._convertVocabulariesToJson(otVocabularyObjects);
        }

        const otEventObjects = graph.filter(x => x.properties != null && ['ObjectEvent', 'AggregationEvent', 'TransactionEvent', 'TransformationEvent'].includes(x.properties.objectType));

        const otEventsByType = {};
        for (const otEventObject of otEventObjects) {
            if (otEventsByType[otEventObject.properties.objectType] == null) {
                otEventsByType[otEventObject.properties.objectType] = [];
            }
            otEventsByType[otEventObject.properties.objectType]
                .push(this._convertOTEventToJson(otEventObject));
        }

        if (otEventObjects.length > 0) {
            json['epcis:EPCISDocument'].EPCISBody = {
                EventList: otEventsByType,
            };
        }

        if (json['epcis:EPCISDocument'].EPCISBody.EventList.TransformationEvent) {
            json['epcis:EPCISDocument'].EPCISBody.EventList.extension = {
                TransformationEvent: json['epcis:EPCISDocument'].EPCISBody.EventList.TransformationEvent,
            };
            delete json['epcis:EPCISDocument'].EPCISBody.EventList.TransformationEvent;
        }
        return xml2js.js2xml(json, {
            compact: true,
            spaces: 4,
        });
    }

    /**
     * Converts vocabulary master data from JSON format to OT-JSON
     */
    _convertVocabulariesFromJson(object) {
        let root = object['epcis:EPCISDocument'];
        if (root == null) {
            throw new Error('Invalid EPCIS document!');
        }

        root = root.EPCISHeader;
        if (root == null) {
            return [];
        }

        root = root.extension;
        if (root == null) {
            return [];
        }

        root = root.EPCISMasterData;
        if (root == null) {
            return [];
        }

        root = root.VocabularyList;
        if (root == null) {
            return [];
        }

        root = root.Vocabulary;
        if (root == null) {
            return [];
        }

        const result = [];
        for (const vocabulary of root) {
            const { type } = vocabulary._attributes;
            const vocabularyElements = vocabulary.VocabularyElementList.VocabularyElement;
            for (const vocabularyElement of vocabularyElements) {
                const properties = {
                    objectType: 'vocabularyElement',
                    vocabularyType: type,
                    ___metadata: this._extractMetadata(vocabularyElement),
                };

                for (const attribute of vocabularyElement.attribute) {
                    if (this._isLeaf(attribute)) {
                        properties[attribute._attributes.id] = attribute._text.trim();
                    } else {
                        properties[attribute._attributes.id] = this._compressText(attribute);
                    }
                }

                const otVocabulary = {
                    identifiers: [],
                };
                if (vocabularyElement._attributes.id) {
                    otVocabulary.identifiers =
                        Object.entries(this._parseGS1Identifier(vocabularyElement._attributes.id))
                            .map(([key, value]) => ({ '@type': key, '@value': value }));
                }

                otVocabulary.identifiers.push(...this._findIdentifiers(vocabularyElement));

                otVocabulary['@id'] = vocabularyElement._attributes.id;
                otVocabulary.properties = properties;
                otVocabulary['@type'] = 'otObject';

                if (vocabularyElement.children) {
                    const compressedChildren = this._compressText(vocabularyElement.children);
                    otVocabulary.properties.children = compressedChildren.id;
                    otVocabulary.relations = [];
                    otVocabulary.properties.children.forEach(id => otVocabulary.relations.push({
                        '@type': 'otRelation',
                        direction: 'direct', // think about direction
                        linkedObject: {
                            '@id': id,
                        },
                        properties: {
                            relationType: 'HAS_CHILD',
                        },
                    }));
                }
                result.push(otVocabulary);
            }
        }
        return result;
    }

    /**
     * Converts vocabulary master data from OT-JSON format to JSON
     */
    _convertVocabulariesToJson(otVocabularyElementList) {
        const elementsByType = {};
        for (const otVocabularyElement of otVocabularyElementList) {
            const { properties } = otVocabularyElement;

            if (properties.___autogenerated === true) {
                // eslint-disable-next-line
                continue;
            }

            delete properties.objectType;
            const type = properties.vocabularyType;
            delete properties.vocabularyType;
            const metadata = properties.___metadata;
            delete properties.___metadata;

            for (const [key, value] of Object.entries(properties)) {
                const m = metadata.attribute.find(x => x._attributes.id === key);
                deepExtend(m, this._decompressText(value));
            }

            const vocabularyElement = metadata;
            if (elementsByType[type] == null) {
                elementsByType[type] = [];
            }

            const { children: otChildren } = otVocabularyElement.properties;
            if (otChildren) {
                vocabularyElement.children = {
                    id: this._decompressText(otChildren),
                };
            }
            elementsByType[type].push(vocabularyElement);
        }

        const vocabulary = {
            Vocabulary: [],
        };

        for (const type of Object.keys(elementsByType)) {
            const vocabularyItem = {
                _attributes: {
                    type,
                },
            };
            vocabularyItem.VocabularyElementList = {
                VocabularyElement: elementsByType[type],
            };
            vocabulary.Vocabulary.push(vocabularyItem);
        }
        return vocabulary;
    }

    /**
     * Converts events to OT-JSON objects
     * @param object - original JSON parsed XML data
     * @return {Array} - Array of Event OT-JSON objects
     * @private
     */
    _convertEventsFromJson(object) {
        const results = [];

        let root = object['epcis:EPCISDocument'];
        if (root == null) {
            throw new Error('Invalid EPCIS document!');
        }

        root = root.EPCISBody;
        if (root == null) {
            return [];
        }

        root = root.EventList;
        if (root == null) {
            return [];
        }

        if (root.ObjectEvent) {
            for (const event of root.ObjectEvent) {
                results.push(this._convertEventFromJson(event, 'ObjectEvent'));
            }
        }
        if (root.AggregationEvent) {
            for (const event of root.AggregationEvent) {
                results.push(this._convertEventFromJson(event, 'AggregationEvent'));
            }
        }

        if (root.TransactionEvent) {
            for (const event of root.TransactionEvent) {
                results.push(this._convertEventFromJson(event, 'TransactionEvent'));
            }
        }

        if (root.extension && root.extension.TransformationEvent) {
            for (const event of root.extension.TransformationEvent) {
                results.push(this._convertEventFromJson(event, 'TransformationEvent'));
            }
        }
        return results;
    }

    /**
     * Converts single Event to OT-JSON event object
     * @param event - Event from original JSON data
     * @param eventType - Event type (ObjectEvent, etc)
     * @return {{"@type": string, "@id": string, identifiers: *[]}}
     * @private
     */
    _convertEventFromJson(event, eventType) {
        const id = `urn:uuid:${uuidv4()}`;

        const otObject = {
            '@type': 'otObject',
            '@id': id,
            identifiers: [{
                '@type': 'uuid',
                '@value': id,
            },
            ],
        };

        otObject.relations = [];
        otObject.properties = {
            objectType: eventType,
        };

        const foundIdentifiers = this._findIdentifiers(event);
        if (foundIdentifiers.length > 0) {
            otObject.identifiers.push(...foundIdentifiers);
        }

        otObject.properties.___metadata = this._extractMetadata(event);
        const compressed = this._compressText(event);

        const createRelation = (id, data) => ({
            '@type': 'otRelation',
            direction: 'direct', // think about direction
            linkedObject: {
                '@id': id,
            },
            properties: data,
        });
        if (compressed.epcList && compressed.epcList.epc) {
            for (const epc of compressed.epcList.epc) {
                otObject.relations.push(createRelation(epc, {
                    relationType: 'EPC',
                }));
            }
        }

        if (compressed.extension) {
            if (compressed.extension.quantityList) {
                for (const epc of compressed.extension.quantityList.quantityElement) {
                    otObject.relations.push(createRelation(epc.epcClass, {
                        relationType: 'EPC_QUANTITY',
                        quantity: epc.quantity,
                        uom: epc.uom,
                    }));
                }
            }

            if (compressed.extension.childQuantityList) {
                for (const childEPCs of compressed.extension.childQuantityList) {
                    for (const childEPC of childEPCs.quantityElement) {
                        otObject.relations.push(createRelation(childEPC.epcClass, {
                            relationType: 'CHILD_EPC_QUANTITY',
                            quantity: childEPC.quantity,
                            uom: childEPC.uom,
                        }));
                    }
                }
            }

            if (compressed.extension.sourceList) {
                for (const source of compressed.extension.sourceList.source) {
                    otObject.relations.push(createRelation(source, {
                        relationType: 'SOURCE',
                    }));
                }
            }

            if (compressed.extension.destinationList) {
                for (const destination of compressed.extension.destinationList.destination) {
                    otObject.relations.push(createRelation(destination, {
                        relationType: 'DESTINATION',
                    }));
                }
            }
        }

        if (compressed.bizLocation) {
            otObject.relations.push(createRelation(
                compressed.bizLocation.id,
                {
                    relationType: 'BIZ_LOCATION',
                },
            ));
        }

        if (compressed.readPoint) {
            otObject.relations.push(createRelation(compressed.readPoint.id, {
                relationType: 'READ_POINT',
            }));
        }

        if (compressed.parentID) {
            otObject.relations.push(createRelation(compressed.parentID, {
                relationType: 'PARENT_EPC',
            }));
        }

        if (compressed.childEPCs) {
            for (const childEPCs of compressed.childEPCs) {
                for (const childEPC of childEPCs.epc) {
                    otObject.relations.push(createRelation(childEPC, {
                        relationType: 'CHILD_EPC',
                    }));
                }
            }
        }

        Object.assign(otObject.properties, compressed);
        return otObject;
    }

    /**
     * Converts OT-JSON event object to original JSON object
     * @param event - OT-JSON object
     * @return {*}
     * @private
     */
    _convertOTEventToJson(event) {
        if (event == null) {
            return null;
        }

        const { properties } = event;
        delete properties.objectType;
        const metadata = properties.___metadata;
        delete properties.___metadata;

        const decompressed = this._decompressText(properties);
        this._appendMetadata(decompressed, metadata);
        return decompressed;
    }

    /**
     * Create OT-JSON connectors
     * @param otEvent - OT-JSON event object
     * @return {Array}
     * @private
     */
    _createConnectors(otEvent) {
        const connectors = [];
        const eventId = otEvent['@id'];
        if (otEvent.properties.bizTransactionList) {
            for (const bizTransaction of otEvent.properties.bizTransactionList.bizTransaction) {
                connectors.push({
                    '@id': `urn:uuid:${uuidv4()}`,
                    '@type': 'otConnector',
                    connectionId: bizTransaction,
                    relations: [
                        {
                            '@type': 'otRelation',
                            direction: 'reverse',
                            linkedObject: {
                                '@id': eventId,
                            },
                            properties: {
                                relationType: 'CONNECTOR_FOR',
                            },
                        },
                    ],
                });
            }
        }
        return connectors;
    }

    /**
     * Utility function that compresses the original JSON object (from XML)
     * @param object - JSON object
     * @return {*}
     * @private
     */
    _compressText(object) {
        if (this._isLeaf(object)) {
            return object._text.trim();
        }
        if (Array.isArray(object)) {
            const clone = [];
            for (const item of object) {
                clone.push(this._compressText(item));
            }
            return clone;
        } else if (typeof object === 'object') {
            const clone = {};
            for (const key of Object.keys(object)) {
                if (!this._isReserved(key)) {
                    clone[key] = this._compressText(object[key]);
                }
            }
            return clone;
        }
    }

    /**
     * Utility function that decompresses compressed document to original JSON (from XML)
     * @param object - decompressed JSON object
     * @return {*}
     * @private
     */
    _decompressText(object) {
        if (Array.isArray(object)) {
            const clone = [];
            for (const item of object) {
                clone.push(this._decompressText(item));
            }
            return clone;
        } else if (typeof object === 'object') {
            const clone = {};
            for (const key of Object.keys(object)) {
                clone[key] = this._decompressText(object[key]);
            }
            return clone;
        }
        return {
            _text: object,
        };
    }

    /**
     * Adds metadata recursively
     */
    _appendMetadata(object, metadata) {
        if (this._isLeaf(object)) {
            if (metadata != null) {
                Object.assign(object, metadata);
            }
        } else if (Array.isArray(object)) {
            for (let i = 0; i < object.length; i += 1) {
                this._appendMetadata(object[i], metadata[i]);
            }
        } else if (typeof object === 'object') {
            for (const key of Object.keys(object)) {
                if (metadata[key] != null) {
                    if (metadata[key]._attributes != null) {
                        object[key]._attributes = metadata[key]._attributes;
                    }
                }
                this._appendMetadata(object[key], metadata[key]);
            }
        }
    }

    /**
     * Extracts metadata from JSON (_comment, _attributes)
     */
    _extractMetadata(object) {
        if (this._isLeaf(object)) {
            const result = {};
            if (object._attributes) {
                result._attributes = object._attributes;
            }
            if (Object.keys(result).length === 0) {
                return null;
            }
            return result;
        }
        if (Array.isArray(object)) {
            const clone = [];
            for (const item of object) {
                clone.push(this._extractMetadata(item));
            }
            return clone;
        } else if (typeof object === 'object') {
            const clone = {};
            for (const key of Object.keys(object)) {
                clone[key] = this._extractMetadata(object[key]);
            }
            if (object._attributes) {
                clone._attributes = object._attributes;
            }
            return clone;
        }
    }

    /**
     * Extracts OT-JSON identifiers from object
     * @param object - JSON Object
     * @param parentKey - Parent key (needed because of recursion)
     * @return {Array}
     * @private
     */
    _findIdentifiers(object, parentKey) {
        const identifiers = [];

        if (Array.isArray(object)) {
            for (const item of object) {
                identifiers.push(...this._findIdentifiers(item, parentKey));
            }
        } else if (typeof object === 'object') {
            if (this._isLeaf(object)) {
                if (object._attributes != null && object._attributes.identifier) {
                    if (parentKey === 'attribute') {
                        identifiers.push({
                            '@type': this._trimIdentifier(object._attributes.id),
                            '@value': object._text,
                        });
                    } else {
                        identifiers.push({
                            '@type': this._trimIdentifier(parentKey),
                            '@value': object._text,
                        });
                    }
                }
            } else {
                for (const key of Object.keys(object)) {
                    identifiers.push(...this._findIdentifiers(object[key], key));
                }
            }
        }
        return identifiers;
    }

    /**
     * Is leaf node in the original JSON document
     * @param object - Original JSON document
     * @return {boolean}
     * @private
     */
    _isLeaf(object) {
        return object._text != null;
    }

    /**
     * Is reserved key in original JSON object
     * @param key - key
     * @return {boolean}
     * @private
     */
    _isReserved(key) {
        return key === '_comment' || key === '_attributes';
    }

    /**
     * Is alphanumeric?
     * @param character
     * @return {boolean}
     * @private
     */
    _alphaNum(character) {
        if (/[^a-zA-Z0-9]/.test(character)) {
            return false;
        }
        return true;
    }

    /**
     * Trims GS1 identifier
     * @param untrimmed
     * @return {string}
     * @private
     */
    _trimIdentifier(untrimmed) {
        const n = untrimmed.length;

        let i = n - 1;

        while (i > 0) {
            if (!this._alphaNum(untrimmed.charAt(i))) {
                i += 1;
                break;
            }

            i -= 1;
        }

        return untrimmed.substring(i);
    }

    /**
     * Parse GS1 identifier into smaller chunks (company, lot, etc)
     * @private
     */
    _parseGS1Identifier(identifier) {
        const regex = /^urn:epc:\w+:(\w+):([\d]+).([\d]+).?(\w+)?$/g;
        const splitted = regex.exec(identifier);

        if (!splitted) {
            throw Error('Invalid Identifier');
        }

        const identifierType = splitted[1];
        const companyPrefix = splitted[2];

        let identifiers = {};
        let checkDigit = 0;
        let itemReference = '';

        switch (identifierType) {
        // eslint-disable-next-line
        case 'sgtin':
            // eslint-disable-next-line
            itemReference = splitted[3];
            const serial = splitted[4];
            checkDigit = this._checkDigitGS1(`${companyPrefix.substr(1)}${itemReference}`);

            identifiers = {
                sgtin: identifier,
                companyPrefix: companyPrefix.substr(1),
                itemReference,
                gtin: `${companyPrefix.substr(1)}${itemReference}${checkDigit}`,
            };

            if (serial) {
                identifiers.serial = serial;
            }
            break;
        // eslint-disable-next-line
        case 'lgtin':
            // eslint-disable-next-line
            itemReference = splitted[3];
            const lotNumber = splitted[4];
            checkDigit = this._checkDigitGS1(`${companyPrefix.substr(1)}${itemReference}`);

            identifiers = {
                lgtin: identifier,
                companyPrefix: companyPrefix.substr(1),
                itemReference,
                gtin: `${companyPrefix.substr(1)}${itemReference}${checkDigit}`,
            };

            if (lotNumber) {
                identifiers.lotNumber = lotNumber;
            }
            break;
        case 'pgln':
        // eslint-disable-next-line
        case 'sgln':
            const locationReference = splitted[3];
            const extension = splitted[4];
            checkDigit = this._checkDigitGS1(`${companyPrefix.substr(1)}${locationReference}`);

            identifiers = {
                sgln: identifier,
                companyPrefix: companyPrefix.substr(1),
                locationReference,
                gln: `${companyPrefix.substr(1)}${locationReference}${checkDigit}`,
            };

            if (extension) {
                identifiers.extension = extension;
            }
            break;
        default:
            throw Error('Invalid identifier type');
        }
        return identifiers;
    }

    /**
     * Gets GS1 digit
     * @param n
     * @return {number}
     * @private
     */
    _checkDigitGS1(n) {
        const l = n.length;
        let v = 0;
        let p = false;

        for (let i = l - 1; i >= 0; i -= 1) {
            // eslint-disable-next-line
            if ((p = !p)) {
                v += (parseInt(n[i], 10) * 3);
            } else {
                v += parseInt(n[i], 10);
            }
        }
        return ((Math.ceil(v / 10) * 10) - v);
    }

    /**
     * If there's only one element, wrap it into array
     */
    arrayze(json, attributes) {
        if (json == null) {
            return null;
        }

        if (Array.isArray(json)) {
            for (const item of json) {
                this.arrayze(item, attributes);
            }
        } else if (typeof json === 'object') {
            for (const key of Object.keys(json)) {
                if (attributes.includes(key)) {
                    if (!Array.isArray(json[key])) {
                        json[key] = [json[key]];
                    }
                }
                this.arrayze(json[key], attributes);
            }
        }
    }

    /**
     * Gets transpilation information.
     * Diff should be populated with unparsed data from original EPCIS document
     * @return *
     */
    _getTranspilationInfo() {
        const created = new Date();
        return {
            transpilationInfo: {
                transpilerType: 'GS1-EPCIS',
                transpilerVersion: '1.0',
                sourceMetadata: {
                    created: created.toISOString(),
                    modified: created.toISOString(),
                    standard: 'GS1-EPCIS',
                    XMLversion: '1.0',
                    encoding: 'UTF-8',
                },
                diff: {},
            },
        };
    }
}

module.exports = EpcisOtJsonTranspiler;
