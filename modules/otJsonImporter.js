const { sha3_256 } = require('js-sha3');

const Utilities = require('./Utilities');
const { forEach, forEachSeries } = require('p-iteration');

// TODO: remove after.
const Graph = require('./Graph');
const GraphStorage = require('./Database/GraphStorage');
const argv = require('minimist')(process.argv.slice(2));
const log = require('./logger');
const pjson = require('../package.json');
const configjson = require('../config/config.json');
const homedir = require('os').homedir();
const path = require('path');
const rc = require('rc');

const defaultConfig = configjson[
    process.env.NODE_ENV &&
    ['development', 'staging', 'stable', 'mariner', 'production'].indexOf(process.env.NODE_ENV) >= 0 ?
        process.env.NODE_ENV : 'development'];

let config;
try {
    // Load config.
    config = rc(pjson.name, defaultConfig);

    if (argv.configDir) {
        config.appDataPath = argv.configDir;
    } else {
        config.appDataPath = path.join(
            homedir,
            `.${pjson.name}rc`,
            process.env.NODE_ENV,
        );
    }
} catch (error) {
    console.error(`Failed to read configuration. ${error}.`);
    console.error(error.stack);
    process.abort();
}

// Helper functions.

/**
 * Returns value of '@id' property.
 * @param jsonLdObject JSON-LD object.
 * @return {string}
 * @private
 */
function _id(jsonLdObject) {
    return jsonLdObject['@id'];
}

/**
 * Returns value of '@type' property.
 * @param jsonLdObject JSON-LD object.
 * @return {string}
 * @private
 */
function _type(jsonLdObject) {
    return jsonLdObject['@type'];
}

/**
 * Returns value of '@value' property.
 * @param jsonLdObject JSON-LD object.
 * @return {string}
 * @private
 */
function _value(jsonLdObject) {
    return jsonLdObject['@value'];
}

/**
 * Returns value of '@context' property.
 * @param jsonLdObject JSON-LD object
 * @returns {*}
 * @private
 */
function _context(jsonLdObject) {
    return jsonLdObject['@context'];
}


/**
 * Calculate SHA3 from input objects and return normalized hex string.
 * @param rest An array of input data concatenated before calculating the hash.
 * @return {string} Normalized hash string.
 * @private
 */
function _keyFrom(...rest) {
    return Utilities.normalizeHex(sha3_256([...rest].reduce(
        (acc, argument) => {
            acc += Utilities.stringify(argument, 0);
            return acc;
        },
        '',
    )));
}

/**
 *
 */
class JsonLdImporter {
    /**
     * Default constructor
     * @param ctx IoC context
     */
    constructor(ctx) {
        this.db = ctx.graphStorage;
        this.helper = ctx.gs1Utilities;
        this.log = ctx.logger;
        this.config = ctx.config;
        this.notifyError = ctx.notifyError;

        this.me = {
            dataCreator: {
                identifiers: [
                    {
                        identifierValue: '0x00624f564D433Db4449Ee10Cdc2cCcdcf46beb68',
                        identifierType: 'ERC725',
                        validationSchema: '/schemas/erc725-main',
                    },
                ],
            },
        };

        // Temporary create arango connection from here
        if (this.db == null) {
            this.db = new GraphStorage(config.database, log);
        }
    }

    process(document) {
        // TODO: validate document here.

        const datasetId = _id(document);
        const header = document.datasetHeader;
        const dataCreator = document.datasetHeader.dataCreator.identifiers[0].identifierValue;

        // Result
        const vertices = [];
        const edges = [];

        document['@graph'].forEach((otObject) => {
            switch (_type(otObject)) {
            case 'otObject': {
                // Create entity vertex.
                const entityVertex = {};
                entityVertex._key = _keyFrom(dataCreator, _id(otObject));
                entityVertex.uid = _id(otObject);
                entityVertex.vertexType = 'EntityObject';
                // TODO: videti sa aleksom da li ide .data.objectType
                entityVertex.objectType = 'otObject';
                entityVertex.datasets = [datasetId];

                vertices.push(entityVertex);

                // Add identifiers.
                otObject.identifiers.forEach((identifier) => {
                    // TODO: check for duplicates here.
                    // TODO: see what with autogenerated here?
                    const identifierVertex = {
                        _key: _keyFrom(_type(identifier), _value(identifier)),
                        identifierType: _type(identifier),
                        identifierValue: _value(identifier),
                        vertexType: 'Identifier',
                        datasets: [datasetId],
                    };
                    vertices.push(identifierVertex);

                    // Add identity edge.
                    const identifyEdge = {
                        _key: _keyFrom(dataCreator, identifierVertex._key, entityVertex._key),
                        _from: identifierVertex._key,
                        _to: entityVertex._key,
                        relationType: 'IDENTIFIES',
                        edgeType: 'IdentifierRelation',
                        datasets: [datasetId],
                    };
                    if (identifier.autogenerated != null) {
                        identifyEdge.autogenerated = identifier.autogenerated;
                    }
                    edges.push(identifyEdge);

                    const identifiedByEdge = {
                        _key: _keyFrom(dataCreator, entityVertex._key, identifierVertex._key),
                        _from: entityVertex._key,
                        _to: identifierVertex._key,
                        relationType: 'IDENTIFIED_BY',
                        edgeType: 'IdentifierRelation',
                        datasets: [datasetId],
                    };
                    if (identifier.autogenerated != null) {
                        identifiedByEdge.autogenerated = identifier.autogenerated;
                    }
                    edges.push(identifiedByEdge);
                });

                // Add data vertex.
                if (otObject.properties != null) {
                    const dataVertex = {
                        _key: _keyFrom(dataCreator, _keyFrom(otObject.properties)),
                        vertexType: 'Data',
                        data: otObject.properties,
                        datasets: [datasetId],
                    };
                    vertices.push(dataVertex);

                    // Add has-data edge.
                    const hasDataEdge = {
                        _key: _keyFrom(dataCreator, entityVertex._key, dataVertex._key),
                        _from: entityVertex._key,
                        _to: dataVertex._key,
                        edgeType: 'dataRelation',
                        relationType: 'HAS_DATA',
                        datasets: [datasetId],
                    };
                    edges.push(hasDataEdge);
                }

                // Add relations edges.
                if (otObject.relations != null) {
                    otObject.relations.forEach((relation) => {
                        const relationEdge = {};
                        relationEdge._from = entityVertex._key;
                        relationEdge._to = _keyFrom(dataCreator, _id(relation.linkedObject));
                        relationEdge.edgeType = 'otRelation';
                        relationEdge.relationType = relation.properties.relationType;
                        relationEdge._key = _keyFrom(
                            dataCreator,
                            relationEdge._from,
                            relationEdge._to,
                            relationEdge.relationType,
                        );
                        relationEdge.properties = relation.properties;
                        relationEdge.datasets = [datasetId];
                        edges.push(relationEdge);
                    });
                }
            }
                break;
            case 'otConnector': {
                // Create connector vertex.
                const connectorVertex = {
                    _key: _keyFrom(dataCreator, _id(otObject)),
                    uid: _id(otObject),
                    connectionId: otObject.connectionId,
                    vertexType: 'Connector',
                    objectType: 'otConnector',
                    datasets: [datasetId],
                };
                vertices.push(connectorVertex);

                // Add relations edges.
                if (otObject.relations != null) {
                    otObject.relations.forEach((relation) => {
                        const relationEdge = {};
                        relationEdge._from = connectorVertex._key;
                        relationEdge._to = _keyFrom(dataCreator, _id(relation.linkedObject));
                        relationEdge._key =
                            _keyFrom(dataCreator, relationEdge._from, relationEdge._to);
                        relationEdge.edgeType = 'otRelation';
                        relationEdge.relationType = relation.properties.relationType;
                        relationEdge.properties = relation.properties;
                        relationEdge.datasets = [datasetId];
                        edges.push(relationEdge);
                    });
                }
            }
                break;
            default:
                throw Error('Only otObject type expected in @graph.');
            }
        });

        // console.log('vertices', vertices);
        // console.log('edges', edges);
        this.vertices = vertices;
        this.edges = edges;
        this.dataCreator = dataCreator;

        const metadata = {
            _key: datasetId,
            datasetContext: _context(document),
            datasetHeader: document.datasetHeader,
            vertices: vertices.reduce((acc, current) => {
                if (!acc.includes(current._key)) {
                    acc.push(current._key);
                }
                return acc;
            }, []),
            edges: edges.reduce((acc, current) => {
                if (!acc.includes(current._key)) {
                    acc.push(current._key);
                }
                return acc;
            }, []),
        };

        this.metadata = metadata;
        // console.log(metadata);
    }

    async write() {
        await this.db.connect();
        await forEachSeries(this.vertices, vertex => this.db.addVertex(vertex));
        await forEachSeries(this.edges, edge => this.db.addEdge(edge));

        await forEachSeries(this.vertices.filter(vertex => vertex.vertexType === 'Connector'), async (vertex) => {
            // Connect to other connectors if available.
            const relatedConnectors = await this.db.findConnectors(vertex.connectionId);

            await forEachSeries(relatedConnectors, async (relatedVertex) => {
                await this.db.addEdge({
                    _key: _keyFrom(this.dataCreator, vertex._key, relatedVertex._key),
                    _from: vertex._key,
                    _to: relatedVertex._key,
                    relationType: 'CONNECTION_DOWNSTREAM',
                    edgeType: 'ConnectorRelation',
                });

                // Other way. This time host node is the data creator.
                await this.db.addEdge({
                    _key: _keyFrom(this.me, relatedVertex._key, vertex._key),
                    _from: relatedVertex._key,
                    _to: vertex._key,
                    relationType: 'CONNECTION_DOWNSTREAM',
                    edgeType: 'ConnectorRelation',
                });
            });
        });

        await this.db.addDocument('ot_datasets', this.metadata);
    }


    async getImport(datasetId) {
        await this.db.connect();

        const vertices = await this.db.findVerticesByImportId(datasetId);
        const edges = await this.db.findEdgesByImportId(datasetId);
        const metadata = await this.db.findMetadataByImportId(datasetId);


        const document = {
            '@id': datasetId,
            '@type': 'Dataset',
            '@graph': [],
        };

        document['@context'] = metadata.datasetContext;
        document.datasetHeader = metadata.datasetHeader;

        vertices.filter(vertex => vertex.vertexType === 'EntityObject').forEach((entityVertex) => {
            const otObject = {
                '@type': 'otObject',
                '@id': entityVertex.uid,
                identifiers: [],
            };

            // Check for identifiers.
            // Relation 'IDENTIFIES' goes form identifierVertex to entityVertex.
            edges.filter(edge => (edge.edgeType === 'IdentifierRelation' && edge._to === entityVertex._key))
                .forEach((edge) => {
                    vertices.filter(vertices => vertices._key === edge._from)
                        .forEach((identityVertex) => {
                            if (edge.autogenerated != null) {
                                otObject.identifiers.push({
                                    '@type': identityVertex.identifierType,
                                    '@value': identityVertex.identifierValue,
                                    autogenerated: edge.autogenerated,
                                });
                            } else {
                                otObject.identifiers.push({
                                    '@type': identityVertex.identifierType,
                                    '@value': identityVertex.identifierValue,
                                });
                            }
                        });
                });
            // Check for properties.
            // Relation 'HAS_DATA' goes from entityVertex to dataVertex.
            edges.filter(edge => (edge.edgeType === 'dataRelation' && edge._from === entityVertex._key))
                .forEach((edge) => {
                    vertices.filter(vertices => vertices._key === edge._to)
                        .forEach((dataVertex) => {
                            otObject.properties = Utilities.copyObject(dataVertex.data);
                        });
                });
            // Check for relations.
            edges.filter(edge => (edge.edgeType === 'otRelation' && edge._from === entityVertex._key))
                .forEach((edge) => {
                    if (otObject.relations == null) {
                        otObject.relations = [];
                    }

                    // Find original vertex to get the @id.
                    const id = (vertices.filter(vertex => vertex._key === edge._to)[0]).uid;

                    otObject.relations.push({
                        '@type': 'otRelation',
                        direction: 'direct', // TODO: check this.
                        linkedObject: {
                            '@id': id,
                        },
                        properties: edge.properties,
                    });
                });
            document['@graph'].push(otObject);
        });

        vertices.filter(vertex => vertex.vertexType === 'Connector').forEach((connectorVertex) => {
            const otConnector = {
                '@type': 'otConnector',
                '@id': connectorVertex.uid,
                connectionId: connectorVertex.connectionId,
            };

            // Check for relations.
            edges.filter(edge => (edge.edgeType === 'otRelation' && edge._from === connectorVertex._key))
                .forEach((edge) => {
                    if (otConnector.relations == null) {
                        otConnector.relations = [];
                    }

                    // Find original vertex to get the @id.
                    const id = (vertices.filter(vertex => vertex._key === edge._to)[0]).uid;

                    otConnector.relations.push({
                        '@type': 'otRelation',
                        direction: 'reverse',
                        linkedObject: {
                            '@id': id,
                        },
                        properties: edge.properties,
                    });
                });

            document['@graph'].push(otConnector);
        });

        return document;
    }
}

module.exports = JsonLdImporter;
